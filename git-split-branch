#!/bin/bash

functions=$(cat << \EOF
map()
{
	# if it was not rewritten, take the original
	if test -r "$workdir/../map/$1"
	then
		cat "$workdir/../map/$1"
	else
		echo "$1"
	fi
}

# if you run 'skip_commit "$@"' in a commit filter, it will print
# the (mapped) parents, effectively skipping the commit.

skip_commit()
{
	shift;
	while [ -n "$1" ];
	do
		shift;
		map "$1";
		shift;
	done;
}

# if you run 'git_commit_non_empty_tree "$@"' in a commit filter,
# it will skip commits that leave the tree untouched, commit the other.
git_commit_non_empty_tree()
{
	if test $# = 3 && test "$1" = $(git rev-parse "$3^{tree}"); then
		map "$3"
	else
		git commit-tree "$@"
	fi
}
# override die(): this version puts in an extra line break, so that
# the progress is still visible

die()
{
	echo >&2
	echo "$*" >&2
	exit 1
}
EOF
)

eval "$functions"

finish_ident() {
	# Ensure non-empty id name.
	echo "case \"\$GIT_$1_NAME\" in \"\") GIT_$1_NAME=\"\${GIT_$1_EMAIL%%@*}\" && export GIT_$1_NAME;; esac"
	# And make sure everything is exported.
	echo "export GIT_$1_NAME"
	echo "export GIT_$1_EMAIL"
	echo "export GIT_$1_DATE"
}

set_ident () {
	parse_ident_from_commit author AUTHOR committer COMMITTER
	finish_ident AUTHOR
	finish_ident COMMITTER
}

USAGE="[-d <directory>] [-r <branch>] <sbranch>
	<dbranch> <files>... [-- <dbranch> <files>...]..."
OPTIONS_SPEC=
. git-sh-setup

if [ "$(is_bare_repository)" = false ]; then
	require_clean_work_tree 'split a branch'
fi

tempdir=.git-rewrite
rembr=
srcbr=
while arg=$1; shift
do
	case "$arg" in
	--)
		break
		;;
	-d*)
		tempdir=${arg:2}
		if [ -z "$tempdir" ]; then
			tempdir=$1
			shift || usage
		fi
		;;
	-r*)
		rembr=${arg:2}
		if [ -z "$rembr" ]; then
			rembr=$1
			shift || usage
		fi
		;;
	-?*)
		usage
		;;
	*)
		srcbr=$arg
		break
		;;
	esac
done

[ -n "$srcbr" ] || usage

# By default, rewrite source branch to remainder in place
: ${rembr:=$srcbr}

# Now read and parse destination specs
dstbrs=
declare -A dstfiles=()
while branch=$1 && shift; do
	dstbrs+=$(git rev-parse --sq-quote "$branch")
	dstfiles[$branch]=
	while arg=$1 && shift; do
		case $arg in
			--)
				break
				;;
			*)
				dstfiles[$branch]+=$(git rev-parse --sq-quote "$arg")
				;;
		esac
	done
done

echo "Source: $srcbr"
echo "Remainder: $rembr"
echo "Branches:"
eval set -- "$dstbrs"
for branch; do
	printf ' - %s:' "$branch"
	eval set -- "${dstfiles[$branch]}"
	for path; do
		printf ' %s' "$path"
	done
	echo
done

orig_dir=$(pwd)
mkdir -p "$tempdir/t" &&
tempdir="$(cd "$tempdir"; pwd)" &&
	cd "$tempdir/t" &&
	workdir="$(pwd)" ||
	die ""

# Remove tempdir on exit
trap 'cd "$orig_dir"; rm -rf "$tempdir"' 0

GIT_INDEX_FILE="$(pwd)/../index"
export GIT_INDEX_FILE

# Set up ID map for rewriting parents on each branch
eval set -- "$dstbrs" "$rembr"
for branch; do
	mkdir ../map-"$branch" || die "Could not create map-$branch/ directory"
done

git rev-list --reverse --topo-order --default HEAD \
	--parents --simplify-merges "$srcbr" >../revs ||
	die "Could not get the commits"
commits=$(wc -l <../revs | tr -d " ")

test $commits -eq 0 && die "Found nothing to rewrite"

# Rewrite the commits
report_progress ()
{
	if test -n "$progress" &&
		test $git_filter_branch__commit_count -gt $next_sample_at
	then
		count=$git_filter_branch__commit_count

		now=$(date +%s)
		elapsed=$(($now - $start_timestamp))
		remaining=$(( ($commits - $count) * $elapsed / $count ))
		if test $elapsed -gt 0
		then
			next_sample_at=$(( ($elapsed + 1) * $count / $elapsed ))
		else
			next_sample_at=$(($next_sample_at + 1))
		fi
		progress=" ($elapsed seconds passed, remaining $remaining predicted)"
	fi
	printf "\rRewrite $commit ($count/$commits)$progress    "
}

git_filter_branch__commit_count=0

progress= start_timestamp=
if date '+%s' 2>/dev/null | grep -q '^[0-9][0-9]*$'
then
	next_sample_at=0
	progress="dummy to ensure this is not empty"
	start_timestamp=$(date '+%s')
fi

while read commit parents; do
	git_filter_branch__commit_count=$(($git_filter_branch__commit_count+1))

	report_progress

	GIT_COMMIT=$commit
	export GIT_COMMIT
	git cat-file commit "$commit" >../commit ||
		die "Cannot read commit $commit"

	eval "$(set_ident <../commit)" ||
		die "setting author/committer failed for commit $commit"

	{
		while IFS='' read -r header_line && test -n "$header_line"
		do
			# skip header lines...
			:;
		done
		# and output the actual commit message
		cat
	} <../commit >../message

	tmptree=$commit

	eval set -- "$dstbrs"
	for branch; do
		# Get just the specified files into the index
		git read-tree --empty
		eval set -- "${dstfiles[$branch]}"
		git reset $tmptree -- "$@"

		# XXX make map take a $branch parameter, update other uses
		parentstr=
		for parent in $parents; do
			for reparent in $(map "$parent"); do
				case "$parentstr " in
				*" -p $reparent "*)
					;;
				*)
					parentstr="$parentstr -p $reparent"
					;;
				esac
			done
		done

		newtree=$(git write-tree)
		git commit-tree "$newtree" $parentstr < ../message > "../map-$branch/$commit" ||
			die "could not write rewritten commit"

		# Set up new tree without extracted files
		GIT_ALLOW_NULL_SHA1=1 git read-tree -i -m $tmptree ||
			die "Could not initialize the index"
		git rm --cached --ignore-unmatch -- "$@"
		tmptree=$(git write-tree)
	done

	# XXX apply Extract Method :)
	# XXX make map take a $branch parameter, update other uses
	parentstr=
	for parent in $parents; do
		for reparent in $(map "$parent"); do
			case "$parentstr " in
			*" -p $reparent "*)
				;;
			*)
				parentstr="$parentstr -p $reparent"
				;;
			esac
		done
	done

	newtree=$tmptree
	git commit-tree "$newtree" $parentstr < ../message > "../map-$branch/$commit" ||
		die "could not write rewritten commit"
done <../revs

srcrev=$(git rev-parse "$srcbranch")
eval set -- "$dstbrs"
for branch; do
	printf 'create refs/heads/%s %s\n' "$branch" "$(map "$branch" "$srcrev")"
done | git update-ref --stdin
